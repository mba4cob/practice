# Libraries Included:
# Numpy, Scipy, Scikit, Pandas

print("Hello, world!")


# 
# Old Content below(Python 2):
# 
# # Libraries Included:
# # Numpy, Scipy, Scikit, Pandas
# 
# print "Hello, world!"
# # 1. Given a String, Check whether it is a Palindrome or not. Input : abba , Output : True
# # a -> b -> b -> a
# 
# # 2. Given an unsorted list, find kth largest element. Input : [2,7,4,3,8,1] , K =2 . Output : 7
# 
# # 3. Minimum number of swaps required to make 2nd list same as 1st.  Input : [2 ,7, 4,1 ,8] [2,8,1,7,4] , Output : 3
# 
# #
# 
# class Node:
#     def __init__(self, val):
#         self.data = val
#         self.next = None
#         
#         
# class LinkedList:
#       def __init__(self):
#         self.head = None
#         
#       
#       def create(self, arr):
#              
#             for c in arr:
#                 cur = Node(val)
#             
#                 if self.head is None:
#                     self.head = cur
#                     node = cur
#                 
#                 prev.next = cur
#                 prev = node
#          
#        """
#        def display(self):
#             node = self.head
#             while(node):
#                 print("d :", node.data)
#        """
#                 
#              
#         
#     
#     
# class Node:
#     def __init__(self):
#         self.data = None
#         self.next = None
#         
# class LinkedList:
#     def __init__(self):
#         self.head = None
# 
#     def create(self, a):
#         
# 
# 
# 
# def find_mid(node):
#     
#     slow = node
#     fast = node
#     
#     while(fast is not None):
#         
#         if fast.next:
#             fast = fast.next.next
#             
#         slow = slow.next
#         
#     return slow
# 
# 
# def reverse(node):
#     if node is None or node.next is None:
#         return node
# 
#     last_node = node.next
#     head = reverse(node.next)
#     last_node.next = node
#     return head
# 
# 
# 
# 
# def palindrome(node):
#     if node is None:
#         return True
# 
#     mid = find_mid(node)
#     
#     head1 = node
# 
#     head2 = reverse(mid)
#     
#     while(head1 && head2):
#         if head1.data == head2.data:
#             head1 = head1.next
#             head2 = head2.next
#         else:
#             return False
#     
# 
# ll = LinkedList()
# ll.create("abba")
# 
#     
#     
#     
#     
# 
#     
#     
#     
#     
#     
# 
# 
# def palindrome():
#     
#     if n
# 